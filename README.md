# javascript-racingcar-precourse

---

## 회고

---

### 1. 지원서에 작성한 목표를 얼마나 달성하고 있다고 생각하나요? 그 이유는 무엇인가요?

퍼센트로 따지면 50% 정도 달성하고 있다고 생각합니다.  
1주차 프리코스 과제를 진행 할때 생각을 제대로 정립하지 않는 습관을 고치기 위해서 기존에 설정 했던 목표 '기능을 작성하기 전에 구현 목록에 대해서 글로 작성' 을 실시 한 후에 기능 개발을 하기로 했지만, 좋지 않은 습관이 바로 나와버려서 진행 중간부터 제가 설정한 목표대로 프리코스를 진행하기 시작했습니다.  
2주차 프리코스는 1주차때 인지했던 문제를 보완하기 위해서 기능을 작성하기 전에 주석으로 구현할 사항들에 대해서 정리를 하고 정리한 내용을 기준으로 구현을 실시 해보았습니다. 하지만 1주차때 역량 상승에 효과적이었던 '학습 내용에 대한 정리'를 많이 소훌히 하게 되었습니다.  
주차 별로 한가지씩 미흡한 부분이 발견 되어서 이후 3-4주차 프리 코스 진행 시에는 최대한 제가 목표로 했던 사항에 대해서 지키면서 진행하도록 노력하겠습니다.

---

### 2. 지원서에 작성한 목표를 변경해야 한다고 생각하시나요? 그렇다면 그 이유와 어떤 목표로 변경하고 싶으신가요?

지금 어쩔 수 없이 일을 하면서 프리코스를 진행하고 있습니다. 12시간 일을 하고 온 후에 자기 전에 프리코스를 진행하다 보니 절대적으로 시간이 부족했고 어짜피 기능 구현이랑 요구사항을 만족한 것 같은데 굳이 내가 설정했던 목표를 완벽하게 이뤄야하나 라는 생각이 들긴 했지만 1-2 주차를 지내면서 얻은 효과가 너무 매력적이었습니다.  
기능 구현을 하기 전에 구현할 사항들을 정리 후에 구현해 보니 이전에 프로그래밍을 할때 보다 훨씬 수월하게 구현이 가능했고, 기능 구현이 완료된 이후에 제가 구현한 기능에 대해서 글로 작성하는 시간을 가져보니 보완할 점을 발견할 수 있어서 좀더 가독성 있는 코드를 작성할 수 있었다고 판단이 되었습니다.  
제가 가용할 수 있는 시간이 많이 제한되지만 그 시간동안 만큼은 최대한 몰입하고 개인 목표 설정 및 달성하려는 노력을 통해서 발전한 저의 모습이 보여서, 욕심같아서는 다른 목표도 추가해서 진행하고 싶지만, 지금 설정한 것이라도 제대로 지키면서 진행을 해보자는 생각을 하게 되어서 목표를 변경해야 한다는 생각은 들지 않습니다.

---

### 3. 프리코스를 진행하면서 눈에 띄는 변화나 깨달은 점이 있나요?

과제가 주어진 후 이틀동안은 프로그래밍을 진행하지 않고 업무시간 중에 시간이 날때마다 1주차 공통 피드백을 자세히 보았습니다. 그 중에서 가장 저에게 와닿은 항목은 **추가 학습 자료** 항목의 문자열 덧셈 계산기 피드백 영상이었습니다. 영상에서는 우리들에게 주어진 시간이 한정 되어 있기 때문에 일단은 요구 사항을 최우선으로 충족하고 해당 사항이 완료가 되었다고 판단 되었을때 추가적인 고려사항, 변수명 구체화, Refactor 등을 진행하는 것이 좋다는 설명이 있었습니다.  
개인적인 이유로 인해 저의 가용시간이 길지 않았기 때문에 프리코스를 진행하면서 최우선으로 요구사항을 충족한 후에 기능이 완성되었다고 판단 되었을때 제가 작성한 코드를 보완하는 과정을 거치니 훨씬 수월하게 기능 구현이 되는 것을 깨달았습니다.  
이전에는 처음부터 모든것을 고려한 후에 진행하는 것이 최종적인 결과가 좋을 것이라는 생각을 가지고 있어서 처음부터 계획을 완벽하게 새우고 진행을 했었습니다. 하지만 이렇게 진행을 해보니 중간에 수정사항이 생기거나 제가 고려하지 못한 부분이 발견되었을때 무엇을 어떻게 진행해야하는지에 대한 방향을 잃을 때가 많았고, 수정이 난잡하게 이루어져 결국 제가 표현하고자 하는 바를 정확하게 드러내지 못했다는 생각이 들었습니다.  
하지만 이번 주차 프리코스를 진행하면서 제시된 요구사항 충족을 최우선으로 하여 진행을 해보았고, 이로 인해 한가지에 몰입해서 구현을 하다보니 이전보다 훨씬 수월하게 구현에 성공할 수 있었습니다.  

테스트에 대해서 학습을 하고 작은 기능이 완성이 된 후에 해당 기능에 대한 테스트 코드를 작성해보니 제가 구현한 기능에서 무엇이 문제이고, 이후 Refactor를 진행할때 제가 표현하고자 하는 것이 제대로 기능을 하는 것을 확인하는 과정이 이전보다 훨씬 수월해졌습니다.  
이전에는 제가 구현한 것을 직접 구동시켜서 동작을 확인하는 방식으로 진행을 하다보니 시간도 오래걸리고 Refactor가 진행 되었을때 제대로 작동하지 않는 상황이 발생했을때 무엇이 문제인지 파악하는 시간이 많이 소요 되었습니다.  
하지만 이번 프리코스를 통해서 기능 단위로 테스트 코드를 작성해보니 문제 파악이 이전보다 훨씬 수월해졌고, 코드의 안정성도 많이 상승되었다고 판단됩니다.

## 구현 기능 목록

### **입력**

#### 경주할 자동차 이름 입력

> **초기 기획**
>
> ```javascript
> 
> 1. 사용자의 입력을 비동기로 입력받고 변수에 저장한다
> 2. 변수의 문자열을 쉼표로(,) split해서 배열로 변환한다
> 3. 배열로 변환된 값의 각 요소의 유효성을 검사한다
>  - 5자 이하인 값인지 검사한다
>  - 유효성을 통과하지 못했을 경우 에러를 반환한다
> 4. 유효성을 통과한 값의 배열을 반환한다
> 
> ```

---

> **최종 구현**
>
> ```javascript
> carNameInput()
>
> 1. Console.readLineAsync를 활용해서 사용자에게 입력 값을 받고 상수에 저장한다(상수명: USER_INPUT)
> 2. split 메소드를 활용해서 입력 받은 문자열을 (',')로 나눠서 배열로 변환한다(상수명: CAR_LIST)
> 3. checkCarName(CAR_LIST)으로 입력값의 유효성을 검사한다
> 4. 유효성을 통과한 CAR_LIST를 반환한다.
> ```
>
> ```javascript
> checkCarName(carList)
>
> 1. 매개변수: carList
> 2. forEach 메소드를 활용해서 배열내 값의 유효성을 검사한다.
>   - 글자 수가 5 초과인지
>   - 글자 수가 0 인지
>   - 중복된 요소가 존재하는지
>     1. filter 메소드를 활용해서 배열을 생성
>     2. filter한 배열의 값이 1개 이상일 경우 에러를 발생
> 3. 유효성 검사에 해당하는 메시지를 선언
> 4. 메시지를 활용하여 에러 객체를 생성
> 5. throw Error
> ```

#### 시도할 횟수 입력

> **초기 기획**
>
> ```javascript
> 1. 사용자의 입력을 비동기로 입력 받는다
> 2. 입력받은 문자열을 Number로 변환한다
> 3. 변환한 입력값의 유효성을 검사한다.
>  - NaN, 1 미만, decimal, 
>  - 유효성을 통과하지 못했을 경우 에러를 던진다
> 4. 유효성을 통과한 정수 값을 반환한다.
> ```

---

> **최종 구현**
>
> ```javascript
> trialCountInput()
> 
> 1. Console.readLineAsync를 활용해서 사용자의 입력을 받아서 상수에 저장(상수명: USER_INPUT)
> 2. USER_INPUT을 Number로 변환한 상수를 선언(상수명: TRIAL_COUNT)
> 3. checkTrialCount(TRIAL_COUNT) 로 입력값의 유효성을 검사
> 4. 유효성을 통과한 TRIAL_COUNT를 반환
> ```
>
> ```javascript
> checkTrialCount(trialCount)
>
> 1. 매개변수: trialCount
> 2. 분기문을 활용하여 유효성 검사를 실시
>   - isNaN, 1보다 작은 값, decimal
> 3. 유효성에 문제가 있을 경우 해당 에러 메시지를 선언
> 4. 에러 메시지를 활용해서 에러 객체를 생성
> 5. throw ERROR
> ```

### **진행 상황 저장**

> **초기 기획**
>
> ```javascript
> 
>   1. 유효성을 통과한 자동차 이름의 배열을 매개 변수로 받는다
>   2. 해당 배열을 map 메서드를 이용해서 ['자동차 이름', ''] 형태로 변환
>   3. 변환된 배열을 활용해서 Map 자료구조를 생성
>   4. Map을 반환
>   
> ```

---

> **최종 구현**
>
> ```javascript
> createRacerInformation(racerList)
> 
> 1. 매개변수(racerList)
> 2. map 메소드를 활용하여 racerList를 [ 자동차 이름, '' ] 형태로 변환하여 상수로 선언(상수명: DEFAULT_RACER_LIST)
> 3. Map 생성자를 활용하여 DEFAULT_RACER_LIST를 사용하여 새로운 Map을 생성(상수명: RACER_MAP)
> RACER_MAP을 반환
> ```

### **출력**

#### 1. 차수별 실행 결과

> 초기 기획

```javascript
  1.~ 매개 변수로 자동차 배열, 레이스 초기 데이터, 시행 횟수를 받는다
  2. 레이스 결과를 저장할 레이스 데이터를 선언
  3. 반복문을 활용하여 시행 횟수와 레이서의 수만큼 레이스 결과를 실행한다
    - goStopResult의 결과를 변수에 저장
    - 해당 결과를 레이스 데이터에 set
    - 한 사이클을 돌은 결과를 출력
  4. 레이스 결과를 반환
```

---

> 최종 구현
>
> ```javascript
> raceProgression(carList, initialRaceHistory, trialCount)
> 
> 1. 매개변수: carList, initialRaceHistory, trialCount
> 2. 레이스 진행 결과를 저장한 상수를 선언(상수명: RACE_PROGRESS)
> 3. 반복문을 활용하여 시행 횟수 만큼 문자열을 출력
>   - 반복 횟수 : trialCount
>   - 출력할 문자열의 변수를 초기화(변수명: singleRace)
>   - 레이스 진행 결과를 구분하기 위해 시행 횟수가 0이 아닐 경우 (\n)을 변수에 대입
>   - forEach 메소드를 활용하여 carList의 횟수 만큼 반복을 실행
>     - goStopResult()를 호출하여 진행 여부를 상수에 저장(상수명: GO_STOP)
>     - 기존 진행 결과와 현재 진행 결과를 상수에 저장(상수명: PROGRESS_RESULT)
>     - 해당 결과를 레이스 진행 결과에 set
>     - 출력할 문자열에 `자동차 이름 : PROGRESS_RESULT` 을 더함
> - 1회 실행 결과를 출력
> 4. 레이스의 진행 결과를 반환
> ```

### **전진, 멈춤**

> 초기 기획
>
> ```javascript
> 1. Random.pickNumberInRange 를 활용하여 0 ~ 9 사이의 무작위 숫자를 생성
> 2. let result = '' 로 변수 초기화
> 3. 생성된 숫자가 4 이상일 경우를 분기
>     - 4 이상일 경우 "-" 를 result에 할당
> 4. result를 반환
> ```

---

> 최종 구현
>
> ```javascript
> goStopResult()
> 
> 1. Random.pickNumberInRange(0, 9)를 활용하여 0 ~ 9 사이의 값을 상수에 저장(상수명: RANDOM_NUMBER)
> 2. 반환한 변수를 '' 로 초기화(변수명: result)
> 3. 분기문을 활용해서 RANDOM_NUMBER가 4 이상일 경우 result에 '-' 를 대입
> 4. result를 반환
> ```

### 우승자 안내 문구

> 초기 기획
>
> 1. 매개변수로 레이스 결과가 저장된 Map, 자동차 리스트를 받는다
> 2. 출력할 결과 문구의 변수를 초기화 한다 (최종 우승자: 자동차 이름)
> 3. 우승자를 저장할 빈 배열을 생성한다
> 4. 반복문을 사용해서 자동차 리스트를 활용해 레이스 결과를 순회한다
>     - 레이스 결과 Map을 확인하여 value 값을 확인 후 우승자 배열에 추가한다.
> 5. 우승자 배열을 ' ,' 을 기준으로 join하여 문자열로 변환한다.
> 6. 결과 문구와 우승자 문구를 합친다
> 7. 우승자를 출력한다
>

---

> 최종 구현
>
>
> ```javascript
> getWinner(carlist, raceProgress)
>
> 1. 매개변수: carList, raceProgress 
> 2. 우승자를 출력할 기본 텍스트를 상수로 선언(상수명: RESULT_DEFAULT_TEXT)
> 3. getResultCountArray(carList, raceProgress)를 호출하여 레이스 결과 (형태: '---')를 숫자로 변환한 배열을 얻는다
> 4. sort 메소드를 활용하여 숫자를 기준으로 배열을 정렬한다
> 5. getRaceWinners(RACE_RESULT_COUNT)를 호출하여 우승자의 이름, 진행 결과를 얻는다.
> 6. 우승자의 이름을 출력하기 위해 진행 결과를 제외한 배열을 상수로 선언(상수명:WINNER_NAMES)
> 7. join 메소드를 활용하여 배열을 문자열로 변환한 상수를 선언(상수명: WINNER_TEXT)
> 8. 기본 텍스트와 우승자 이름 문자열을 합친다
> 9. 최종 우승자를 출력한다
> ```
>
> ```javascript
> getResultCountArray(carList, raceProgress)
>
> 1. 매개변수: carList, raceProgress
> 2. map 메소드를 활용하여 문자열 형태의 레이스 결과('-')를 변환한 배열을 생성한다
>     - Map형태의 진행결과 데이터에서 레이스 결과를 가져온다
>     - 레이스 결과를 ('-' -> 문자열의 길이)로 변환한다
>     - [자동차 이름, 문자열의 길이] 형태로 변환한다
> 3. 생성된 배열을 반환한다
> ```
>
> ```javascript
> getRaceWinners(raceResultCountArray)
> 
> 1. 매개변수: raceResultCountArray
> 2. 빈 배열을 상수로 선언한다(상수명: WINNERS)
> 3. forEach 메소드를 활용하여 배열을 순회한다
>     - 자동차의 진행 결과를 상수로 선언한다(상수명: RACE_LENGTH)
>     - 첫번째 시도에서는 WINNERS에 첫번째 요소를 push한다
>     - 이후의 시도에서는 WINNERS 배열에 존재하는 값의 진행 결과와 순회하는 값의 진행 결과를 비교한다
>         - 진행 결과가 같을 경우 WINNERS 배열에 자동차의 정보를 push 한다
> 4. WINNERS를 반환한다
> ```

---

## 개인 학습

[package-lock.json](https://github.com/thumbthing/javascript-racingcar-7/blob/thumbthing/study/package-lock.json.md)  
[jest](https://github.com/thumbthing/javascript-racingcar-7/blob/thumbthing/study/jest.md)  
[JavaScript](https://github.com/thumbthing/javascript-racingcar-7/blob/thumbthing/study/javascript.md)  